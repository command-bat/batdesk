<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <title>Compartilhamento de Tela - Transmissor</title>
</head>

<body style="background-color: #3a316b;">
    <input id="name" placeholder="Nome da transmissão" />
    <button id="start">Iniciar Compartilhamento</button>
    <div id="link"></div>

    <script src="/socket.io/socket.io.js"></script>

    <script>
        const socket = io();
        const startButton = document.getElementById('start');
        const nameInput = document.getElementById('name');
        const linkDiv = document.getElementById('link');
        let screenStream;

        startButton.addEventListener('click', async () => {
            try {
                screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: {
                        // Solicita o áudio da guia ou sistema se suportado
                        echoCancellation: false,
                        noiseSuppression: false,
                        sampleRate: 44100
                    }
                });
                socket.emit('broadcaster', { name: nameInput.value || 'Sem nome' });
            } catch (err) {
                console.error("Erro ao capturar a tela:", err);
            }
        });

        socket.on('broadcast-id', (id) => {
            linkDiv.innerHTML = `<p>Link da transmissão: <a href="/viewer?id=${id}" target="_blank">/viewer?id=${id}</a></p>`;
        });

        const peers = {};
        socket.on('watcher', async (id) => {
            const peerConnection = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            });

            screenStream.getTracks().forEach(track => peerConnection.addTrack(track, screenStream));
            peerConnection.onicecandidate = event => {
                if (event.candidate) socket.emit('candidate', id, event.candidate);
            };
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            socket.emit('offer', id, peerConnection.localDescription);
            peers[id] = peerConnection;
        });

        socket.on('answer', (id, description) => {
            peers[id].setRemoteDescription(description);
        });

        socket.on('candidate', (id, candidate) => {
            peers[id].addIceCandidate(new RTCIceCandidate(candidate));
        });

        socket.on('disconnectPeer', id => {
            if (peers[id]) {
                peers[id].close();
                delete peers[id];
            }
        });


        setInterval(() => {
            socket.emit('keep-alive');
        }, 15000); // a cada 15 segundos


        socket.on('disconnected', () => {
            alert('A conexão com o servidor foi perdida. A transmissão foi encerrada.');
            location.reload(); // ou qualquer outro comportamento desejado
        });
    </script>